

'''
        Подвиг 2. Объявите в программе функцию с именем get_even, которая способна принимать
        произвольное количество чисел в качестве аргументов.
        Например:

        get_even(1, 2, 3, -5, 10, 8)

        Функция должна возвращать список, составленный только из четных переданных ей значений.

        P.S. Функцию вызывать не нужно, только определить.

        Sample Input:

        45 4 8 11 12 0
        Sample Output:

        4 8 12 0
'''



def get_even(*args):
    return [i for i in args if i % 2 == 0]


print(get_even(45, 4, 8, 11, 12, 0))




'''
        Подвиг 3. 
        
        Объявите в программе функцию с именем get_biggest_city, которой можно передавать 
        произвольное количество названий городов (строк) через аргументы. 
        Например:

        get_biggest_city('Город 1', 'Город 2', 'Город 3', 'Город 4')
        
        Данная функция должна возвращать название города (строку) наибольшей длины. 
        Если таких городов несколько, то первый переданный (из наибольших). 
        Программу реализовать без использования сортировки.
        
        P.S. Функцию выполнять не нужно, только определить.
        
        Sample Input:
        
        Питер Москва Самара Воронеж
        Sample Output:
        
        Воронеж
'''


def get_biggest_city(*args):
    str_ex = ""
    for city in args:
        if len(city) > len(str_ex):
            str_ex = city
    return str_ex

print(get_biggest_city("Питер", "Москва", "Самара", "Воронеж"))


# Вариант 2

def get_biggest_city(*args):
    return max(args, key=len)


print(get_biggest_city("Питер", "Москва", "Самара", "Воронеж"))




'''
        Подвиг 4. 
        
        Объявите в программе функцию с именем get_data_fig для вычисления периметра произвольного N-угольника. 
        На вход этой функции передаются N длин сторон через ее аргументы. 
        Дополнительно могут быть указаны именованные аргументы:

        tp - булево значение True/False;
        color - целое числовое значение;
        closed - булево значение True/False;
        width - вещественное значение.
        
        Функция должна возвращать в виде кортежа периметр многоугольника и указанные значения 
        именованных параметров в порядке их перечисления в тексте задания (если они были переданы). 
        Если какой-либо параметр отсутствует, его возвращать не нужно (пропустить).
        
        P.S. Функцию выполнять не нужно, только объявить.
        
        
        Sample Input:
        
        1 2 3 4 3 2 4
        Sample Output:
        
        19
        19 True
        19 True 7
        19 False 2.0
'''


# def get_data_fig(*args, **kwargs):
#     if kwargs:
#         rez = ()
#         if "tp" in kwargs:
#             rez = rez + (kwargs['tp'],)
#         if "color" in kwargs:
#             rez = rez + (kwargs['color'],)
#         if "closed" in kwargs:
#             rez = rez + (kwargs['closed'],)
#         if "width" in kwargs:
#             rez = rez + (kwargs['width'],)
#         return (sum(args), ) + rez
#     else:
#         return (sum(args), )




#Вариант 2

def get_data_fig(*args, **kwargs):
    kwargs = [kwargs[i] for i in ['tp', 'color', 'closed', 'width'] if i in kwargs]
    return (sum(args), *kwargs)



rez1 = get_data_fig(1, 2, 3, 4, 3, 2, 4, color=5, tp=True,  closed=False, width=1.0)
print(*rez1)

rez2 = get_data_fig(1, 2, 3, 4, 3, 2, 4)
print(*rez2)




'''
        Большой подвиг 5. 
        
        (Для закрепления предыдущего материала). 
        На вход программе подается таблица целых чисел (см. пример ниже) размером N x N элементов 
        (N определяется по входным данным). 
        Необходимо прочитать эти числа и сохранить в виде двумерного (вложенного) списка lst2D 
        размером N x N элементов. 
        Полученная таблица будет содержать нули и кое-где единицы. 
        С помощью функции с именем verify, на вход которой подается двумерный список чисел (первый параметр), 
        необходимо проверить, являются ли единицы изолированными друг от друга, 
        то есть, вокруг каждой единицы должны быть нули.
        
        Рекомендуется следующий алгоритм. 
        
        В функции verify производить перебор двумерного списка. 
        Для каждого элемента (списка) со значением 1 вызывать еще одну вспомогательную функцию 
        is_isolate для проверки изолированности единицы. 
        То есть, функция is_isolate должна возвращать True, 
        если единица изолирована и False в противном случае.
        
        Как только встречается не изолированная единица, функция verify должна возвращать False. 
        Если успешно доходим (по элементам списка) до конца, то возвращается значение True.
        
        Функцию verify выполнять не нужно, только объявить.
        
        P. S. При реализации функции is_isolate не следует прописывать восемь операторов if. 
        Подумайте, как это можно сделать красивее (с точки зрения реализации алгоритма). 
        
        Sample Input:
        
        1 0 0 0 0
        0 0 1 0 0
        0 0 0 0 0
        0 1 0 1 0
        0 0 0 0 0
        Sample Output:
        
        True
'''

lines = ['1 0 0 0 0\n', '0 0 1 0 0\n', '0 0 0 0 0\n', '0 1 0 1 0\n', '0 0 0 0 0\n']

lst2D = [list(map(int, i.split())) for i in lines]
print(lst2D)

def verify(lst: list) -> bool:
    flag = True
    for i in range (len(lst) - 1 ):
        for j in range (len(lst) - 1):
            if (lst[i][j] + lst[i][j+1] + lst[i+1][j] + lst[i+1][j+1]) > 1:
                flag = False
                break
    return flag


print(verify(lst2D))





'''
        Значимый подвиг 6. 
        
        (Для закрепления предыдущего материала). 
        
        Объявите в программе функцию с именем str_min, 
        которая сравнивает две переданные строки (через два первых параметра) 
        и возвращает минимальную из них (то есть, выполняется лексикографическое сравнение строк). 
        Следом объявите еще две аналогичные функции:
        
        с именем str_min3 для поиска минимальной строки из трех переданных строк;
        с именем str_min4 для поиска минимальной строки из четырех переданных строк.
        Причем при реализации функций str_min3 и str_min4 следует использовать 
        вызов (результат работы) функции str_min.
        
        P.S. Выполнять функции не нужно, только объявить.
'''

def str_min(a, b):
    return a if a < b else b


def str_min3(a, b, c):
    return a if a < str_min(b, c) else str_min(b, c)

def str_min4(a, b, c, d):
    return str_min(a, b) if str_min(a, b) < str_min(c, d) else str_min(c, d)

s1 = "Причем при реализации функций"
s2 = "для поиска минимальной строки из"
s3 = "Выполнять функции не нужно"
s4 = "Следом объявите еще две аналогичные функции:"
print(str_min(s1, s2))
print(str_min3(s1, s2, s3))
print(str_min4(s1, s2, s3, s4))