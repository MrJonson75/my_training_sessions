'''
        Подвиг 1.

        На вход программе подаются целые числа, записанные через пробел.
        Прочитайте эту строку и сохраните через какую-либо переменную.

        Напишите функцию, которая имеет один параметр,
        преобразовывает переданную ей строку в список чисел и возвращает их сумму.

        Определите декоратор для этой функции, который имеет один параметр start - начальное значение суммы.
        Примените декоратор со значением start=5 к функции и вызовите декорированную
        функцию для прочитанной строки. Результат (сумму) отобразите на экране.

        Sample Input:

        5 6 3 6 -4 6 -1
        Sample Output:

        26
'''

def dec(start=5):
    def decorator(func):
        def wrapper(*args, **kwargs):
            rez = func(*args, **kwargs) + start
            return rez
        return wrapper
    return decorator

@dec()
def sum_list(string):
    return sum(list(map(int, string.split())))


str_in = "5 6 3 6 -4 6 -1"

print(sum_list(str_in))





'''
        Подвиг 2. 
        
        Объявите функцию, которая переводит символы строки в нижний регистр (малые буквы) и 
        возвращает результат. 
        Определите декоратор для этой функции, который имеет один параметр tag, 
        определяющий строку с названием тега и начальным значением "h1". 
        Этот декоратор должен заключать возвращенную функцией строку в тег tag и возвращать результат.
        
        Пример заключения строки "python" в тег h1:
        
        <h1>python</h1>
        
        Примените декоратор со значением tag="div" к функции и вызовите декорированную 
        функцию для строки s, прочитанной из входного потока:
        
        s = input()
        Результат работы декорированной функции отобразите на экране.
        
        Sample Input:
        
        Декораторы - это классно!
        Sample Output:
        
        <div>декораторы - это классно!</div>
'''

def dec(tag="h1"):
    return lambda func: lambda *args: f"<{tag}>{func(func(*args))}</{tag}>"


@dec(tag="div")
def low_str(s):
    return s.lower()


s = "Декораторы - это классно!"
print(low_str(s))





'''
        Подвиг 3. 
        
        Объявите функцию, которая принимает строку с кириллицей (и другими символами) 
        и преобразовывает русские буквы в латиницу, используя следующий словарь для замены русских 
        букв на соответствующее латинское написание:
        

        t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
             'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
             'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
             'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}
             
             
        Функция должна возвращать преобразованную строку. 
        Замены делать без учета регистра (переданную строку перевести в нижний регистр - малые буквы). 
        
        Определите декоратор с параметром chars и начальным значением " !?", 
        который данные символы преобразует в символ "-" и, кроме того, 
        все подряд идущие дефисы (например, "--" или "---") приводит к одному дефису. 
        Полученный результат должен возвращаться в виде строки.
        
        Примените декоратор с аргументом chars="?!:;,. " 
        к функции и вызовите декорированную функцию для строки s:
        
        s = input()
        Результат работы декорированной функции отобразите на экране.

        Sample Input:
        
        Декораторы - это круто!
        Sample Output:
        
        dekoratory-eto-kruto-
'''


t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
     'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
     'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
     'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'
     }

def decor(chars="?!:;,. "):
    def decorator(func):
        def wrapper(*args):
            rez = "".join(["-" if i in chars else i for i in func(*args)])
            while "--" in rez:
                rez = rez.replace("--", "-")
            return rez
        return wrapper
    return decorator


@decor()
def str_to_slug(string):
    return "".join([t.get(i) if i in t else i for i in (string.lower())])


s = "Декораторы - это круто!"
print(str_to_slug(s))




'''
        Подвиг 4. Объявите функцию с именем get_list, одним параметром и следующим описанием в теле функции:

            'Функция для формирования списка целых значений'

        Сама функция должна формировать и возвращать список целых чисел, 
        который передается ей на вход в виде строки из целых чисел, записанных через пробел.
        
        Определите декоратор, который выполняет суммирование значений списка, 
        возвращаемого декорируемой функцией и возвращает результат. 
        Внутри декоратора декорируйте переданную функцию с помощью команды 
        @wraps (не забудьте сделать импорт: from functools import wraps).
        
        Такое декорирование необходимо, чтобы исходная функция get_list 
        сохраняла свои локальные свойства: __name__ и __doc__.
        
        Примените декоратор к функции get_list, но не вызывайте ее.
'''
from functools import wraps

def sum_list(func):
    @wraps(func)
    def wrapper(*args):
        return sum(func(*args))
    return wrapper


@sum_list
def get_list(string):
    """
    Функция для формирования списка целых значений
    """
    return list(map(int, string.split()))