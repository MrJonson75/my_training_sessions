'''
        Подвиг 1.

        Объявите функцию с именем get_sq, которая вычисляет площадь прямоугольника по двум параметрам:
        width и height - ширина и высота прямоугольника, и возвращает результат
        (сама ничего на экран не выводит). То есть, функция имеет сигнатуру:

        def get_sq(width, height): ...
        Определите декоратор func_show для этой функции, который отображает результат на экране в виде строки
        (без кавычек):

        "Площадь прямоугольника: <значение>"

        Вызывать функцию и декоратор не нужно, только объявить. Применять декоратор к функции также не нужно.

        Sample Input:

        8 11
        Sample Output:

        Площадь прямоугольника: 88
'''
from zoneinfo import reset_tzpath


def func_show(func):
    def wrapper(*args, **kwargs):
        rez = func(*args, **kwargs)
        print(f"Площадь прямоугольника: {rez}")
        return rez
    return wrapper


@func_show
def get_sq(width, height):
    return width * height


r = get_sq(1,2)


'''
        Подвиг 2. 
        
        На вход программы поступает строка с названиями пунктов меню, записанные в одну строчку через пробел. 
        В программе реализовано чтение этой строки командой:

        menu = input()
        Необходимо задать функцию с именем get_menu с сигнатурой:
        
        def get_menu(s): ...
        которая преобразует переданную ей строку s в список из слов и возвращает этот список.
        
        Определите декоратор для этой функции с именем show_menu, который отображает список на экран в формате:
        1. Пункт_1
        2. Пункт_2
        ...
        N. Пункт_N
        
        Примените декоратор show_menu к функции get_menu, используя оператор @. 
        Более ничего в программе делать не нужно. Сами функции не вызывать.
       
        Sample Input:
        
        Главная Добавить Удалить Выйти
        Sample Output:
        
        1. Главная
        2. Добавить
        3. Удалить
        4. Выйти
'''


def show_menu(func):
    def wrapper(*args, **kwargs):
        rez = func(*args, **kwargs)
        for i in range(1, len(rez)+1):
            print(f"{i}. {rez[i-1]}")

    return wrapper


@show_menu
def get_menu(s):
    return list(s.split())


menu = "Главная Добавить Удалить Выйти"
get_menu(menu)






'''
        Подвиг 3. 
        
        На вход программы поступает строка из целых чисел, записанных через пробел. 
        Необходимо прочитать эту строку и сохранить в какой-либо переменной.

        Напишите функцию get_list с одним параметром, которая преобразовывает эту строку в список 
        из целых чисел и возвращает его. 
        Определите декоратор для функции get_list, который сортирует список чисел по возрастанию. 
        Результат сортировки должен возвращаться в виде списка чисел при вызове декорированной функции.
        
        Вызовите декорированную функцию get_list и отобразите полученный отсортированный список lst командой:
        
        print(*lst)
        
        Sample Input:
        
        8 11 -5 4 3 10
        Sample Output:
        
        -5 3 4 8 10 11
'''


def sort_lisr(func):
    def wrapper(*args, **kwargs):
        rez = func(*args, **kwargs)
        rez.sort()
        return rez
    return wrapper


@sort_lisr
def get_list(string):
    return list(map(int, string.split()))

# string_in = input()

string_in = "8 11 -5 4 3 10"
lst = get_list(string_in)
print(*lst)




'''
        Подвиг 4. 
        
        На вход программе поступают две строки. 
        В каждой строке записаны слова через пробел. 
        Прочитайте эти строки и сохраните их в двух переменных.

        Объявите функцию с двумя параметрами, которой передаются строки со словами и 
        преобразовываются в два списка из слов. 
        Функция должна возвращать кортеж с этими списками в порядке: 
        
        сначала первый список (первой строки), затем - второй.
        
        Определите декоратор для этой функции, который из двух списков формирует словарь, 
        в котором ключами являются слова из первого списка, а значениями - соответствующие 
        элементы из второго списка. 
        Длины списков полагаются равными. 
        Полученный словарь должен возвращаться при вызове декоратора.
        
        Примените декоратор к первой функции и вызовите ее для прочитанных строк. 
        Результат (словарь d) отобразите на экране командой:
        
        print(*sorted(d.items()))
        
        Sample Input:
        
        house river tree car
        дом река дерево машина
        Sample Output:
        
        ('car', 'машина') ('house', 'дом') ('river', 'река') ('tree', 'дерево')

'''


def list_dict(func):
    def wrapper(*args, **kwargs):
        rez = func(*args, **kwargs)
        return dict(zip(rez[0], rez[1]))
    return wrapper


@list_dict
def str_tuple(str_key, str_val):
    return str_key.split(), str_val.split()



key = "house river tree car"
values = "дом река дерево машина"
d = str_tuple(key, values)
print(*sorted(d.items()))





'''
        Подвиг 5. 
        
        Объявите функцию, которая принимает строку с кириллицей и латиницей и преобразовывает 
        русские символы в латиницу, используя следующий словарь для замены русских букв на 
        соответствующее латинское написание:

        t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
             'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
             'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
             'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}
             
        Функция должна возвращать преобразованную строку. 
        Замены делать без учета регистра (переданную строку перевести в нижний регистр - малые буквы). 
        Небуквенные символы " : ;.,_" превращать в символ '-' (дефиса).
        
        Определите декоратор для этой функции, который несколько подряд идущих дефисов, 
        превращает в один дефис. 
        Полученная строка должна возвращаться при вызове декоратора. 
        (Сам декоратор на экран ничего выводить не должен).
        
        Примените декоратор к первой функции и вызовите ее для строки s, 
        прочитанной из входного потока командой:
        
        s = input()
        Результат работы декорированной функции отобразите на экране.
        
        Sample Input:
        
        Python - это круто!
        Sample Output:
        
        python-eto-kruto!
'''
import re
t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
     'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
     'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
     'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}

z = (" ", ":", ";", ".", "_", ",")


def del_(func):
    def wrapper(*args, **kwargs):
        rez = func(*args, **kwargs)
        while "--" in rez:
            rez = rez.replace("--", "-")
        return rez
    return wrapper


@del_
def str_slug(s):
    out = ""
    for char in s.strip().lower():
        if char in z:
            out += "-"
        if char in t:
            out += t[char]
        if char not in t and char not in z:
            out += char
    return out

str_in = "    Python -    - Это : ;.,_ круто!  "

print(str_slug(str_in))