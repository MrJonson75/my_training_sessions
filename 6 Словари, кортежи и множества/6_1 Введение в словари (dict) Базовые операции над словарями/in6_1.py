
'''
        Подвиг 3.

        На вход программе подаются данные в формате ключ=значение, записанные через пробел.
        Значениями здесь являются целые числа (см. пример ниже).
        Необходимо прочитать строку с этими данными и на их основе сформировать словарь d,
        используя функцию dict().
        Результирующий словарь вывести на экран командой:

        print(*sorted(d.items()))
        Sample Input:

        one=1 two=2 three=3
        Sample Output:

        ('one', 1) ('three', 3) ('two', 2)

'''

# lst = input().split()
# d = dict([item.split('=') for item in lst])
# for key, value in d.items():
#     d[key] = int(value)
# print(*sorted(d.items()))





'''
        Подвиг 4. 
        
        На вход программе поступают данные в виде набора строк в формате: 
        
        ключ1=значение1
        ключ2=значение2
        ...
        ключN=значениеN
        
        Ключами здесь выступают целые числа (см. пример ниже). 
        В программе уже реализовано считывание всех строк и сохранение их в виде списка:
        
        lst_in = list(map(str.strip, sys.stdin.readlines()))
        
        
        Необходимо преобразовать список lst_in в словарь d (без использования функции dict()) 
        и вывести полученный словарь на экран командой:
        
        print(*sorted(d.items()))
        Sample Input:
        
        5=отлично
        4=хорошо
        3=удовлетворительно
        
        
        Sample Output:
        
        (3, 'удовлетворительно') (4, 'хорошо') (5, 'отлично')
'''


# lst_in = ["5=отлично", "4=хорошо", "3=удовлетворительно"]

# d = {}
# lst_in = [item.split("=") for item in lst_in]
# for i in range(len(lst_in)):
#     lst_in[i][0] = int(lst_in[i][0])
# for item in lst_in:
#     d[item[0]] = item[1]
# print(*sorted(d.items()))





'''
        Подвиг 5. 
        
        На вход программе подаются данные в формате ключ=значение, записанные через пробел. 
        Необходимо прочитать строку с этими данными и на их основе сформировать словарь. 
        Затем проверить, существуют ли в словаре ключи со значениями: 
        'house', 'True' и '5' (все ключи - строки). 
        Если все они существуют, то вывести на экран "ДА", иначе "НЕТ".
        
        Sample Input:
        
        вологда=город house=дом True=1 5=отлично 9=божественно
        
        Sample Output:
        
        ДА
'''


# d = dict([item.split('=') for item in input().split()])
# if 'house' in d and 'True' in d and '5' in d:
#     print("ДА")
# else:
#     print("НЕТ")





'''
        Подвиг 6. 
        
        На вход программе подаются данные в формате ключ=значение, записанные через пробел. 
        Необходимо прочитать строку с этими данными и на их основе сформировать словарь d. 
        Затем удалить из этого словаря ключи 'False' и '3', если они существуют. 
        Ключами и значениями словаря являются строки. Вывести полученный словарь на экран командой:
        
        print(*sorted(d.items()))
        
        Sample Input:
        
        лена=имя дон=река москва=город False=ложь 3=удовлетворительно True=истина
        Sample Output:
        
        ('True', 'истина') ('дон', 'река') ('лена', 'имя') ('москва', 'город')
'''

# d = dict([item.split('=') for item in input().split()])
# if 'False' in d:
#     del d['False']
# if '3' in d:
#     del d['3']
# print(*sorted(d.items()))



'''
        Подвиг 7. 
        
        На вход программе подаются номера телефонов, записанные в одну строчку через пробел, 
        с разными кодами стран: +7, +6, +2, +4 и т.д. Необходимо прочитать строку и на ее основе 
        сформировать словарь d. Ключами словаря должны быть коды (строки: +7, +6, +2 и т. п.), 
        а значениями список номеров в виде строк (следующих в том же порядке, что и в исходной строке) 
        с соответствующими кодами. Полученный словарь вывести командой:
        
        print(*sorted(d.items()))
        
        Sample Input:
        
        +71234567890 +71234567854 +61234576890 +52134567890 +21235777890 +21234567110 +71232267890
        
        Sample Output:
        ('+2', ['+21235777890', '+21234567110']) ('+5', ['+52134567890']) ('+6', ['+61234576890']) 
        ('+7', ['+71234567890', '+71234567854', '+71232267890'])
'''

# lst = list(map(str, input().split()))
# lst_out =[]
# for i in range(len(lst)):
#     l = []
#     l1 = [lst[i][0:2]]
#     for j in range(len(lst)):
#         if lst[j][:2] == lst[i][:2]:
#             l.append(lst[j])
#     l1.append(l)
#     lst_out.append(l1)
# d = dict(lst_out)
# print(*sorted(d.items()))

# ********************************************************************
# n = input().split()
# d = dict([(x[:2], [i for i in n if x[:2] == i[:2]]) for x in n])
# print(*sorted(d.items()))
#
# *******************************************************************

# d = {}
#
# for i in input().split():
#     d.setdefault(i[:2], []).append(i)
#
# print(*sorted(d.items()))




'''
        Подвиг 8. 
        
        На вход программе поступают номера телефонов с привязкой к именам в виде строк следующего формата:
        
        номер_1 имя_1
        номер_2 имя_2
        ...
        номер_N имя_N
        
        В программе уже реализовано считывание всех строк и сохранение их в виде списка:
        
        lst_in = list(map(str.strip, sys.stdin.readlines()))
        
        На основе списка lst_in необходимо создать словарь d, где ключами будут имена, а значениями - список 
        номеров телефонов для этого имени (ключа). 
        Обратите внимание, что одному имени может принадлежать несколько разных номеров. 
        Полученный словарь вывести командой:
        
        print(*sorted(d.items()))
        
        
        Sample Input:
        
        +71234567890 Сергей
        +71234567810 Сергей
        +51234567890 Михаил
        +72134567890 Николай
        Sample Output:
        
        ('Михаил', ['+51234567890']) ('Николай', ['+72134567890']) ('Сергей', ['+71234567890', '+71234567810'])
'''

lst_in = [
        "+71234567890 Сергей",
        "+71234567810 Сергей",
        "+51234567890 Михаил",
        "+72134567890 Николай"
]
d = {}
for i in [j.split() for j in lst_in]:
    d.setdefault(i[1], []).append(i[0])
print(*sorted(d.items()))






'''
        Подвиг 9. 
        
        На вход программе поступают целые положительные числа. 
        Необходимо с помощью цикла реализовать их считывание, пока не встретится число 0. 
        В теле цикла для каждого прочитанного числа вычисляется квадратный корень (с точностью до сотых) 
        и значение выводится на экран (в столбик). 
        С помощью словаря выполните кэширование данных так, чтобы при повторном вводе того же самого числа 
        результат не вычислялся, а бралось ранее вычисленное значение (из словаря). 
        При этом на экране должно выводиться:
        
        значение из кэша: <число>
        
        Sample Input:
        
        1
        2
        3
        3
        2
        4
        0
        Sample Output:
        
        1.0
        1.41
        1.73
        значение из кэша: 1.73
        значение из кэша: 1.41
        2.0
'''
d = {}
while True:
    n = int(input())
    if n == 0:
        break
    if n not in d:
        d[n] = round(n ** 0.5, 2)
        print(d[n])
    else:
        print(f"значение из кэша: {d[n]}")
**********************************************************************************




'''
        Подвиг 10. 
        
        Тестовый веб-сервер возвращает HTML-страницы по URL-адресам (строкам). 
        На вход программе поступают различные URL-адреса, записанные каждое с новой строки. 
        В программе уже реализовано считывание всех строк и сохранение их в виде списка:
        
        lst_in = list(map(str.strip, sys.stdin.readlines()))
        
        Необходимо перебрать в цикле этот список с URL-адресами и если адрес появился (пришел) впервые, 
        то на экране отобразить строку (без кавычек):
        
        "HTML-страница для адреса <URL-адрес>"
        
        и сохранить в словаре эту строку с ключом текущего URL-адреса. 
        Если же URL-адрес встречается (приходит) повторно (проверяется по ключам словаря), 
        то следует взять строку "HTML-страница для адреса <URL-адрес>" из этого словаря 
        и вывести на экран сообщение (без кавычек):
        
        "Взято из кэша: HTML-страница для адреса <URL-адрес>"
        
        Сообщения выводить каждое с новой строки.
        
        P.S. Подобные задачи на практике решаются через хэш-таблицы. 
        В Python словарь - это хэш-таблица. 
        Скорость поиска ключа в нем выполняется очень быстро (намного быстрее, чем в списке). 
        Именно поэтому решать ее через список очень плохая практика.

        
        Sample Input:
        
        ustanovka-i-zapusk-yazyka
        ustanovka-i-poryadok-raboty-pycharm
        peremennyye-operator-prisvaivaniya-tipy-dannykh
        arifmeticheskiye-operatsii
        ustanovka-i-poryadok-raboty-pycharm
        
        Sample Output:
        
        HTML-страница для адреса ustanovka-i-zapusk-yazyka
        HTML-страница для адреса ustanovka-i-poryadok-raboty-pycharm
        HTML-страница для адреса peremennyye-operator-prisvaivaniya-tipy-dannykh
        HTML-страница для адреса arifmeticheskiye-operatsii
        Взято из кэша: HTML-страница для адреса ustanovka-i-poryadok-raboty-pycharm
'''

lst_in = ['ustanovka-i-zapusk-yazyka', 'ustanovka-i-poryadok-raboty-pycharm',
          'peremennyye-operator-prisvaivaniya-tipy-dannykh', 'arifmeticheskiye-operatsii',
          'ustanovka-i-poryadok-raboty-pycharm']

d = {}
for i in lst_in:
    if i not in d:
        d.setdefault(i, i)
        print(f"HTML-страница для адреса {d[i]}")
    else:
        print(f"Взято из кэша: HTML-страница для адреса {d[i]}")
