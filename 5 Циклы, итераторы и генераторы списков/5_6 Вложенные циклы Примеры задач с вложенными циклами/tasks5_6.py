

'''
        Подвиг 1.

        На вход программе подается натуральное число N (то есть, положительное, целое).

        Требуется его прочитать и создать двумерный (вложенный) список размером N x N элементов,
        состоящий из всех единиц,
        а затем, в последний столбец записать пятерки.
        Вывести этот список на экран в виде таблицы чисел, как показано в примере ниже.

            P.S. Будьте внимательны в конце строк пробелов быть не должно!

            Sample Input:

            4
            Sample Output:

            1 1 1 5
            1 1 1 5
            1 1 1 5
            1 1 1 5
'''
import sys

# n = int(input())
# lst = []
# for i in range(n):
#     temp = []
#     for j in range(n):
#         temp.append(1)
#     lst.append(temp)
#
# for i, row in enumerate(lst):
#     lst[i][n-1] = 5
#
# for i in lst:
#     print(*i)
# *********************************************
#
# n = int(input())
#
# lst = [[1] * n] * n
# lst[0][n-1] = 5
#
# for i in lst:
#     print(*i)
# *********************************************

'''
        Подвиг 2. 
        
        На вход программе подаются строки (URL-адреса, каждая с новой строки). 
        В программе уже реализовано их чтение и сохранение в списке:

        lst_in = list(map(str.strip, sys.stdin.readlines()))
        
        Требуется заменить в строках списка lst_in все пробелы на символ дефиса (-). 
        Следует учесть, что может быть несколько подряд идущих пробелов. 
        Полученные URL-адреса (строки) вывести на экран в столбик в порядке их следования в списке lst_in.
        
        Sample Input:
        
        django chto  eto takoe    poryadok ustanovki
        model mtv   marshrutizaciya funkcii  predstavleniya
        marshrutizaciya  obrabotka isklyucheniy       zaprosov perenapravleniya
        Sample Output:
        
        django-chto-eto-takoe-poryadok-ustanovki
        model-mtv-marshrutizaciya-funkcii-predstavleniya
        marshrutizaciya-obrabotka-isklyucheniy-zaprosov-perenapravleniya
'''

# lst_in = ["django chto  eto takoe    poryadok ustanovki",
#           "model mtv   marshrutizaciya funkcii  predstavleniya",
#           "marshrutizaciya  obrabotka isklyucheniy       zaprosov perenapravleniya"
#           ]


# for i, row in enumerate(lst_in):
#     while row.count(" "):
#         row = row.replace(" ", "-")
#         while row.count("--"):
#             row = row.replace("--", "-")
#     lst_in[i] = row
#
# print(*lst_in, sep="\n")
# ***********************************************

# for i in lst_in:
#     print(i)
#     print(i.split())
#     print('-'.join(i.split()))
# *************************************************




'''
        Подвиг 3. 
        
        На вход программе подается натуральное число n. 
        Необходимо его прочитать и найти все простые числа (нацело делятся только на 1 и на себя), 
        которые меньше числа n, то есть, в диапазоне [2; n). 
        Результат вывести на экран в строчку через пробел.
        
        Ликбез: квадратная скобка - граница включается; круглая скобка - граница исключается. 
        Например [2; n) - диапазон от 2 до n-1 целых чисел.

        Sample Input:
        
        11
        Sample Output:
        
        2 3 5 7
'''
#
# n = int(input())
#
# for num in range(2, n):
#     s = True
#     for i in range(2, num):
#         if num % i == 0:
#             s = False
#     if s:
#         print(num, end=" ")
# ******************************************************
#
# for i in range(2, int(input())):
#     for j in range(2, 1 + i // 2): # i // 2 значительно ускоряет процесс
#         if i % j == 0:
#             break
#     else:
#         print(i, end=' ')
# *********************************************************************


'''
        Подвиг 4. 
        
        На вход программе подается двумерный список размерностью 5 х 5 элементов, 
        состоящий из нулей и в некоторых позициях единицы (см. пример ниже). В
         программе уже реализовано их чтение и сохранение в списке:

        s = sys.stdin.readlines()
        lst_in = [list(map(int, x.strip().split())) for x in s]
        Требуется проверить, не касаются ли единицы друг друга по горизонтали, вертикали и диагонали. Т
        о есть, вокруг каждой единицы должны быть нули. 
        Если проверка проходит вывести на экран "ДА", иначе "НЕТ".
        
        Sample Input:
        
        1 0 0 0 0
        0 0 1 0 1
        0 0 0 0 0
        0 1 0 1 0
        0 0 0 0 0
        Sample Output:
        
        ДА
'''

# lst_in = [[1, 0, 0, 0, 0],
#           [0, 0, 1, 0, 1],
#           [0, 0, 0, 0, 0],
#           [0, 1, 0, 1, 0],
#           [0, 0, 0, 0, 0]
#           ]
# flag = True
# for i, row in enumerate(lst_in):
#     if not row.count(1):
#         continue
#     else:
#         for j, num in enumerate(row):
#             if num == 1:
#                 if i == 0:
#                     if j == 0 and sum(lst_in[i][j:j+2]) + sum(lst_in[i+1][j:j+2]) > 1:
#                         flag = False
#                     elif j == 4 and num + lst_in[i][j-1] + lst_in[i+1][j] + lst_in[i+1][j-1] > 1:
#                         flag = False
#                     elif sum(lst_in[i][j-1:j+2]) + sum(lst_in[i+1][j-1:j+2])  > 1:
#                         flag = False
#                 elif i == 4:
#                     if j == 0 and sum(lst_in[i][j:j+2]) + sum(lst_in[i-1][j:j+2]) > 1:
#                         flag = False
#                     elif j == 4 and num + lst_in[i][j-1] + lst_in[i-1][j] + lst_in[i-1][j-1] > 1:
#                         flag = False
#                     elif sum(lst_in[i][j-1:j+2]) + sum(lst_in[i-1][j-1:j+2])  > 1:
#                         flag = False
#                 elif sum(lst_in[i][j-1:j+2]) + sum(lst_in[i+1][j-1:j+2]) + sum(lst_in[i-1][j-1:j+2]) > 1:
#                     flag = False
#
# if flag:
#     print("ДА")
# else:
#     print("НЕТ")
#
# *********************************************
#
# flag = True
#
# for i in range(len(lst_in)-1):
#     for j in range(len(lst_in)-1):
#         if (lst_in[i][j] + lst_in[i][j+1] + lst_in[i+1][j] + lst_in[i+1][j+1]) > 1:
#             flag = False
#
# print(["НЕТ","ДА"][flag])
#
# **********************************************************


'''
        Подвиг 5. 
        
        На вход программе подается двумерный список размерностью 5 х 5 элементов, 
        состоящий из целых чисел (пример см. ниже). 
        В программе уже реализовано их чтение и сохранение в списке:
        
        s = sys.stdin.readlines()
        lst_in = [list(map(int, x.strip().split())) for x in s]
        
        Необходимо проверить, является ли этот двумерный список симметричным относительно главной диагонали. 
        Главная диагональ — та, которая идёт из левого верхнего угла двумерного массива в правый нижний. 
        Выведите на экран "ДА", если матрица (таблица чисел) симметрична и "НЕТ" в противном случае.
        
        Sample Input:
        
        2 3 4 5 6
        3 2 7 8 9
        4 7 2 0 4
        5 8 0 2 1
        6 9 4 1 2
        Sample Output:
        
        ДА
'''

# lst_in =[
#     [2, 3, 4, 5, 6],
#     [3, 2, 7, 8, 9],
#     [4, 7, 2, 0, 4],
#     [5, 8, 0, 2, 1],
#     [6, 9, 4, 1, 2]
# ]
#
#
# flag = True
# for i in range(len(lst_in)):
#     for j in range(i+1, len(lst_in)):
#         if lst_in[i][j] != lst_in[j][i]:
#             flag = False
# print(["НЕТ", "ДА"][flag])
#
# **************************************************




'''
        Большой подвиг 6. 
        
        На вход программе подаются целые числа, записанные в одну строку через пробел. 
        Необходимо их прочитать и сохранить в списке. 
        Затем, выполнить сортировку выбором полученного списка по возрастанию (неубыванию). 
        Идея алгоритма очень проста и проиллюстрирована на рисунке ниже.
        
        
        
        Вначале мы рассматриваем первый элемент списка и ищем второй минимальный относительно первого 
        элемента (включая и его). 
        На рисунке - это последний элемент со значением -1. 
        Затем, меняем местами первый и последний элементы. 
        Переходим ко второму элементу списка и повторяем эту же процедуру, 
        но относительно второго элемента (то есть, первый уже не рассматриваем). 
        На рисунке минимальный элемент - это 2, поэтому менять местами здесь ничего не нужно. 
        Переходим к 3-му элементы со значением 6. 
        Относительно него находим минимальный элемент - это 3. 
        Меняем их местами. 
        
        Вот идея алгоритма сортировки выбором. 
        Реализуйте его для сформированного списка целых чисел. 
        Результат выведите на экран в виде последовательности чисел, записанных в одну строчку через пробел.
        
        Sample Input:
        
        8 11 -53 2 10 11
        Sample Output:
        
        -53 2 8 10 11 11
'''

# lst_in = list(map(int, input().split()))
#
#
# for ind in range(len(lst_in)):
#     for j in range(ind+1, len(lst_in)):
#         if lst_in[j] < lst_in[ind]:
#             lst_in[j], lst_in[ind] = lst_in[ind], lst_in[j]
#
# print(*lst_in)






'''
        Большой подвиг 7. 
        
        На вход программе подаются целые числа, записанные в одну строку через пробел. 
        Необходимо их прочитать и сохранить в списке. 
        Затем, выполнить сортировку полученного списка по возрастанию (неубыванию) 
        методом всплывающего пузырька. Идея алгоритма проста и показана на рисунке ниже.

        При первом проходе перебираем все соседние пары элементов и если значение предыдущего 
        элемента (слева) больше значения следующего (справа), то они меняются местами. 
        (На рисунке 3 и 2 меняются местами). 
        Следующая пара - это 3 и 6. 
        Они уже выстроены по возрастанию, поэтому ничего не делаем и переходим к следующей паре 6 и -1. 
        Меняем значения местами и видим, что на последнем месте находится максимальное значение 6, что нам и нужно.
        
        При втором проходе делаем все то же самое, но доходим до предпоследнего элемента, так как 
        последнее значение 6 уже отсортировано. На третьем проходе исключаем уже последние два элемента и так далее. 
        То есть, в этом алгоритме достаточно сделать N-1 проходов, где N - длина списка.
        
        Вот идея алгоритма сортировки всплывающего пузырька. 
        Реализуйте его для вводимого списка целых чисел. 
        Результат выведите на экран в виде последовательности чисел, записанных в одну строчку через пробел.
        
        Sample Input:
        
        4 5 2 0 6 3 -56 3 -1
        Sample Output:
        
        -56 -1 0 2 3 3 4 5 6
'''


# lst_in = list(map(int, input().split()))
# for j in range(len(lst_in)):
#     for i in range(len(lst_in) - 1):
#         if lst_in[i] > lst_in[i+1]:
#             lst_in[i], lst_in[i+1] = lst_in[i+1], lst_in[i]
# print(*lst_in)
#
# *****************************************************************


'''
        Подвиг 8. 
        
        В некоторой стране используются денежные купюры достоинством в 1, 2, 4, 8, 16, 32 и 64. 
        
        На вход программы подается натуральное число n. 
        Необходимо его прочитать. 
        Затем определите, каким наименьшим количеством денежных купюр достоинством в 1, 2, 4, 8, 16, 32 и 64 
        можно выплатить сумму n? выведите на экран список купюр для формирования суммы n 
        (в одну строчку через пробел, начиная с наибольшей и заканчивая наименьшей). 
        Предполагается, что имеется достаточно большое количество купюр всех достоинств.
  
        P.S. Программа может быть реализована и без вложенных циклов.

        Sample Input:
        
        221
        Sample Output:
        
        64 64 64 16 8 4 1
'''


n = int(input())
nom = [64, 32, 16, 8, 4, 2, 1]
c = 0
while c < len(nom) :
    if n >= nom[c]:
        print(nom[c], end=" ")
        n -= nom[c]
    else:
        c +=1

